.\" Man page generated from reStructuredText.
.
.TH "PYLAUNCHER" "1" "Jun 30, 2020" "3.2" "PyLauncher"
.SH NAME
pylauncher \- PyLauncher Documentation
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.SH INTRODUCTION AND GENERAL USAGE
.sp
This is the documentation of the pylauncher utility by Victor Eijkhout.
.SS Motivation
.sp
There are various scenarios where you want to run
a large number of serial or low\-corecount parallel jobs.
Many cluster scheduling systems do not allow you to
submit a large number of small jobs (and it would probably
lower your priority!) so it would be a good idea
to package them into one large parallel job.
.sp
Let\(aqs say that you have 4000 serial jobs, and your cluster allows
you to allocate 400 cores, then packing up the serial jobs could
be executed on those 400 cores, in approximately the time of 10 serial jobs.
.sp
The tool to do this packing is called a \fIparametric job launcher\fP\&.
The \(aqparametric\(aq part refers to the fact that most of the time your
serial jobs will be the same program, just invoked with a different input parameter.
One also talks of a \(aqparameter sweep\(aq for the whole process.
.sp
A simple launcher scenario would take a file with command lines,
and give them out cyclicly to the available cores. This mode
is not optimal, since one core could wind up with a few processes
that take much longer than the others. Therefore we want a dynamic launcher
that keeps track of which cores are free, and schedules jobs there.
.sp
In a very ambitious scenario, you would not have a static list of
commands to execute, but new commandlines would be generated
depending on the ones that are finished. For instance, you could have
a very large parameter space, and the results of finished jobs
would tell you what part of space to explore next, and what part
to ignore.
.sp
The pylauncher module supports such scenarios.
.SS Here\(aqs what I want to know: do I have to learn python?
.sp
Short answer: probably not. The pylauncher utility is
written in python, and to use it you have to write a few lines of python.
However, for most common scenarios there are example scripts that you
can just copy.
.sp
Longer answer: only if you want to get ambitious.
For common scenarios there are single function calls which you
can copy from example scripts. However, the launcher is highly customizable,
and to use that functionality you need to understand something about python\(aqs
classes and you may even have to code your own event loop. That\(aqs the price you
pay for a very powerful tool.
.SS Realization
.sp
The pylauncher is a very customizable launcher utility.
It provides base classes and routines that take care of
most common tasks; by building on them you can tailor
the launcher to your specific scenario.
.sp
Since this launcher was developed for use at the Texas Advanced Computing Center,
certain routines are designed for the specific systems in use there.
In particular, processor management is based on the
SGE and SLURM job schedulers and the environment variables they define.
By inspecting the source it should be clear how to customize
the launcher for other schedulers and other environments.
.sp
If you write such customizations, please contact the author.
Ideally, you would fork the repository
\fI\%https://github.com/TACC/pylauncher\fP
and generate a pull request.
.SH A QUICK TUTORIAL
.SS Setup
.sp
You need to have the files \fBpylauncher3.py\fP and \fBhostlist.py\fP in your \fBPYTHONPATH\fP\&.
If you are at TACC, do \fBmodule load pylauncher\fP and all is good.
.SS Batch operation
.sp
The most common usage scenario is to use the launcher to bundle many small jobs
into a single batch submission on a cluster. In that case, put
.INDENT 0.0
.INDENT 3.5
::
module load python3
.sp
::
python3 your_launcher_file.py
.UNINDENT
.UNINDENT
.sp
in the jobscript.
.SS Examples
.sp
There is an \fBexamples\fP subdirectory with some simple scenarios
of how to invoke the pylauncher. We start with a number of launchers
that run inside a parallel (SLURM/SGE/PBS) job.
.SS Single\-core jobs
.sp
In the simplest scenario, we have a file of commandlines,
each to be executed on a single core.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#!/usr/bin/env python

import pylauncher3

##
## Emulate the classic launcher, using a one liner
##

#pylauncher.ClassicLauncher("corecommandlines",debug="job+host+task")
pylauncher3.ClassicLauncher("commandlines",debug="job")


.ft P
.fi
.UNINDENT
.UNINDENT
.sp
where the commandlines file is:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
####
#### This file was automatically generated by: 
#### python make_commandlines.py 256 1 40
####
echo 0 >> /dev/null 2>&1  ; sleep 21
echo 1 >> /dev/null 2>&1  ; sleep 30
echo 2 >> /dev/null 2>&1  ; sleep 8
echo 3 >> /dev/null 2>&1  ; sleep 34
echo 4 >> /dev/null 2>&1  ; sleep 39
echo 5 >> /dev/null 2>&1  ; sleep 9

.ft P
.fi
.UNINDENT
.UNINDENT
.SS Constant count multi\-core jobs
.sp
The next example uses again a file of commandlines, but now the
launcher invocation specifies a core count that is to be used for
each job.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#!/usr/bin/env python

import pylauncher3

##
## Emulate the classic launcher, using a one liner
##

pylauncher3.ClassicLauncher("commandlines",
                           debug="job+task+host+exec+command",
                           cores=2)


.ft P
.fi
.UNINDENT
.UNINDENT
.SS Variable count multi\-core jobs
.sp
If we have multithreaded jobs, but each has its own core count,
we add the core count to the file of commandlines, and we tell
the launcher invocation that that is where the counts are found.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#!/usr/bin/env python

import pylauncher3

##
## Emulate the classic launcher, using a one liner
##

pylauncher3.ClassicLauncher("corecommandlines",
                           debug="job+task+host+exec+command",
                           cores="file",
                           )


.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#
# Automatically generated commandlines
#
5,echo "command 0"; sleep 21
5,echo "command 1"; sleep 14
5,echo "command 2"; sleep 23
5,echo "command 3"; sleep 13
5,echo "command 4"; sleep 29
5,echo "command 5"; sleep 12
5,echo "command 6"; sleep 23

.ft P
.fi
.UNINDENT
.UNINDENT
.SS MPI parallel jobs
.sp
If your program uses the MPI library and you want to run multiple
instances simultaneously, use the \fBIbrunLauncher\fP\&.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
4,./parallel 0 10
4,./parallel 1 10
4,./parallel 2 10
4,./parallel 3 10
4,./parallel 4 10
4,./parallel 5 10
4,./parallel 6 10
4,./parallel 7 10
4,./parallel 8 10
4,./parallel 9 10

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This example uses a provided program, \fBparallel.c\fP of two parameters:
.INDENT 0.0
.IP \(bu 2
the job number
.IP \(bu 2
the number of seconds running time
.UNINDENT
.sp
The program will report the size of its communicator, that is,
on how many cores it is running.
.SS Local jobs
.sp
If you own your computer and you want to run the parallel
the parameter sweep locally, use the \fBLocalLauncher\fP
.sp
Two parameters:
.INDENT 0.0
.IP \(bu 2
name of a file of commandlines
.IP \(bu 2
a count of how many jobs you want to run simultaneously, typically
the number of cores of your machine.
.UNINDENT
.SS Remote jobs
.sp
The launchers so far spawned all jobs on the machine where the launcher python script
is running. It is possible to run the python script in one location (say, a container)
while spawning jobs elsewhere. First, the \fBRemoteLauncher\fP takes a hostlist
and spawns jobs there through an ssh connection:
.INDENT 0.0
.INDENT 3.5
def RemoteLauncher(commandfile,hostlist,**kwargs)
.UNINDENT
.UNINDENT
.sp
Optional arguments:
.INDENT 0.0
.IP \(bu 2
\fBworkdir\fP : location for the temporary files
.IP \(bu 2
\fBppn\fP : how many jobs can be fitted on any one of the hosts
.IP \(bu 2
\fBcores\fP : number of cores allocated to each job
.sp
def IbrunRemoteLauncher(commandfile,hostlist,**kwargs)
.UNINDENT
.sp
Same arguments as the \fBRemoteLauncher\fP, now every job is start as an MPI execution.
.SS Job timeout
.sp
If individual tasks can take a varying amount of time and you may want
to kill them when they overrun some limit, you can add the
.INDENT 0.0
.INDENT 3.5
taskmaxruntime=30
.UNINDENT
.UNINDENT
.sp
option to the launcher command.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#!/usr/bin/env python

import pylauncher3

##
## Classic launcher with a per\-task timeout
##

#pylauncher.ClassicLauncher("corecommandlines",debug="job+host+task")
pylauncher3.ClassicLauncher("commandlines",taskmaxruntime=30,delay=1,debug="job+host")


.ft P
.fi
.UNINDENT
.UNINDENT
.SS Job ID
.sp
The macro
.INDENT 0.0
.INDENT 3.5
PYL_ID
.UNINDENT
.UNINDENT
.sp
gets expanded to the task ID on the commandline.
.SS Job restarting
.sp
If your job runs out of time, it will leave a file \fBqueuestate\fP that
describes which tasks were completed, which ones were running, and
which ones were still scheduled to fun. You can submit a job using the
\fBResumeClassicLauncher\fP:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#!/usr/bin/env python

import pylauncher

##
## This resumes a classic launcher from a queuestate file
##

pylauncher.ResumeClassicLauncher("queuestate",debug="job")

.ft P
.fi
.UNINDENT
.UNINDENT
.SH IMPLEMENTATION
.SS Commandline generation
.sp
The term \(aqcommandline\(aq has a technical meaning:
a commandline is a two\-element list or a tuple where the first member is the
Unix command and the second is a core count. These commandline tuples are generated
by a couple of types of generators.
.sp
The \fBCommandlineGenerator\fP base class handles the
basics of generating commandlines.
Most of the time you will use the derived class \fBFileCommandlineGenerator\fP which
turns a file of Unix commands into commandlines.
.sp
Most of the time a commandline generator will run until some supply of
commands run out. However,
the \fBDynamicCommandlineGenerator\fP class runs forever,
or at least until you tell it to stop, so it is good for
lists that are dynamically replenished.
.SS Host management
.sp
We have an abstract concept of a node, which is a slot for a job.
Host pools are the management structure for these nodes:
you can query a host pool for sufficient nodes to run a multiprocess job.
.sp
A host pool has associated with it an executor object, which represents
the way tasks (see below) are started on nodes in that pool. Executors are also
discussed below.
.SS Task management
.sp
Tasks are generated internally from a \fBTaskGenerator\fP object that
the user can specify. The \fBTaskQueue\fP object is created internally
in a \fBLauncherJob\fP\&.  For the \fBcompletion\fP argument of the \fBTaskGenerator\fP,
see below.
.SS Executors
.sp
At some point a task needs to be executed. It does that by applying the \fBexecute\fP
method of the \fBExecutor\fP object of the \fBHostPool\fP\&. (The thinking
behind attaching the execution to a host pool is that
different hostpools have different execution mechanisms.)
Executing a task takes a commandline and a host locator on which to execute it;
different classes derived from \fBExecutor\fP correspond to different spawning
mechanisms.
.SS Task Completion
.sp
Task management is largely done internally. The one aspect that a user
could customize is that of the completion mechanism: by default each
commandline that gets executed leaves a zero size file behind that is
branded with the task number. The TaskQueue object uses that to detect
that a task is finished, and therefore that its Node objects can be
released.
.sp
Task generators need completions dynamically generated since they need
to receive a job id. You could for instance specify code such as the
following; see the example launchers.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
completion=lambda x:FileCompletion( taskid=x,
             stamproot="expire",stampdir="workdir")
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Jobs
.sp
All of the above components are pulled together in the LauncherJob class.
Writing your own launcher this way is fairly easy;
see the TACC section for some examples of launchers.
.SH TACC SPECIFICS AND EXTENDABILITY TO OTHER INSTALLATIONS
.sp
The pylauncher source has a number of classes and routines
that are tailored to the use at the Texas Advanced Computing Center.
For starters, there are two classes derived from \fBHostList\fP,
that parse the hostlists for the SGE and SLURM scheduler.
If you use Load Leveler or PBS, you can write your own
using these as an example.
.sp
Two utility functions may help you in writing customizations.
.SH TACC LAUNCHERS
.SH TRACING AND PROFILING
.sp
It is possible to generate trace output during a run and profiling
(or summary) information at the end.
.SS Trace output
.sp
You can get various kinds of trace output on your job. This is done by
specifying a \fBdebug=....\fP parameter to the creation of the various classes.
For the easy case, pass \fBdebug="job+host+task"\fP to a launcher object.
.sp
Here is a list of the keywords and what they report on:
.INDENT 0.0
.IP \(bu 2
host: for \fBHostPool\fP objects.
.IP \(bu 2
command: for \fBCommandlineGenerator\fP objects.
.IP \(bu 2
task: for \fBTask\fP and \fBTaskGenerator\fP objects.
.IP \(bu 2
exec: for \fBExecutor\fP objects. For the SSHExecutor this prints out the contents of the temporary file containing the whole environment definition.
.IP \(bu 2
ssh: for \fBSSHExecutor\fP objects.
.IP \(bu 2
job: for \fBLauncherJob\fP objects.
.UNINDENT
.SS Final reporting
.sp
Various classes can produce a report. This is intended to be used at the
end of a job, but you can do it really at any time. The predefined launchers
such as \fBClassicLauncher\fP
print out this stuff by default.
.SH TESTING
.sp
The pylauncher.py source file has a large number of unittests
that are designed for the nosetests framework: all routines and classes
starting with \fBtest\fP are only for testing purposes.
.INDENT 0.0
.IP \(bu 2
genindex
.UNINDENT
.INDENT 0.0
.IP \(bu 2
search
.UNINDENT
.SH AUTHOR
Victor Eijkhout
.SH COPYRIGHT
2013-2020, Victor Eijkhout
.\" Generated by docutils manpage writer.
.
