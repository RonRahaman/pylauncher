\documentclass[11pt]{artikel3}

\usepackage{pslatex}
\usepackage[pdftex,colorlinks]{hyperref}

\newcommand\n[1]{{\tt #1}}

\begin{document}
\title{User Guide for the Python Launcher at TACC}
\author{Victor Eijkhout}
\date{November 2011}
\maketitle

The python launcher is a utility\footnote{We add the qualification
  `python' since TACC also offers a more limited utility, simply
  called `the launcher'.} for executing many instances of a
simple, possibly sequential, program in a single submitted batch
job. For simple jobs, where a static list of commandlines is
available, the user is only required to write a three line python
script (examples below); for more complicated workflows, some python
programming may be required.

\section*{General remarks on using the python launcher}

The launcher module is used inside a batch script. If you do not know
how to write a batch script, please consult the userguide for your
cluster of choice. Inside your batch script, you invoke a launcher
script, which is a short python program:
\begin{verbatim}
# .... the usual batch script stuff
module load pylauncher
python your_launcher_script.py
\end{verbatim}
The python script needs to start with
\begin{verbatim}
import pylauncher
\end{verbatim}
or 
\begin{verbatim}
#!/usr/bin/env python
import pylauncher
\end{verbatim}
if you want to invoke it as an executable shell script.

From now on we will take these lines for given and only discuss the
launcher commands in the script.

Running the pylaunchers leaves behind a temporary directory {\tt pylauncher_tmpdir.123456} (with {\tt 123456} replaced by your job number. This directory can safely be deleted after the launcher job finishes.

\section*{Simple use cases}

In the `classic launcher' setup, the user has made a file containing
commandlines. These commandlines are executed by having this in the
python script:
\begin{verbatim}
pylauncher.ClassicLauncher("commandlines")
\end{verbatim}
where the \n{commandlines} file contains one commandline per line:
\begin{verbatim}
commandline1
echo "this is command 2" ; commandline2
if [ some_test ] ; then commandline3a ; else commandline3b ; fi
.... et cetera
\end{verbatim}
Blank lines are allowed in the commandlines file, and comment lines
starting with \n{\char`\#} are ignored.

The batch job that calls the script will execute these commandlines on
all the nodes and cores that have been requested (again, see the
userguide if you do not yet know how to do this). Each line is
executed in a separate shell, and this shell inherits the user
environment and starts in the current working directory.

In the classic launcher setup each commandline is executed on a single
core. If the commandline calls a multithreaded program, and therefore
more cores are requested, the above call can be altered:
\begin{verbatim}
pylauncher.ClassicLauncher("commandlines",cores=4)
\end{verbatim}

A variable number of cores can be accomodated too, but requires a more
complicated file of commandlines. 
\begin{verbatim}
pylauncher.CoreLauncher("corecommandlines")
\end{verbatim}
where the input file \n{corecommandlines} is
\begin{verbatim}
ncores1,commandline1
ncores2,commandline2
... et cetera
\end{verbatim}

\section*{A dynamic launcher}

The following example code is meant to cover the use case where the
job list is dynamically generated, possibly in response to jobs on the
list finishing and being post-processed. The user now needs to program
a python object that has two methods:
\begin{itemize}
\item \n{generate}. A function with no arguments. This method will be
  called when the launcher has cores available: by calling this method
  the launcher is requesting a new commandline from the user. The
  method should return two variables: the commandline, and the number
  of cores on which to execute it. In other words, your code for this
  method will typically look like
\begin{verbatim}
  def generate(self):
    job = "commandline"
    cores = 4
    return job,cores
\end{verbatim}
  Two exceptions: if there are temporarily no commandlines available,
  the \n{generate} method should return \n{"stall",1}; if the job is
  finished the method should return \n{"stop",1}. (The number of cores
  is irrelevant in these cases.)
\item \n{expire}. A function with one argument \n{id}. This function
  is called whenever a commandline finished, and the argument is then
  the id of that commandline. It is entirely up to the user to parse
  what this id means, and what action to perform
  accordingly. In the following example this function appends a new
  commandline to an internally maintained list, and the \n{generate}
  function then passes these commandlines to the launcher.
\end{itemize}

\begin{verbatim}
#
# a joblist object, which has methods for generating new commandlines
# and for postprocessing finished commands
#
class joblist():
    def __init__(self,list):
        self.list = list; self.njobs = len(self.list)
    def generate(self):
        if self.njobs<30:
            if len(self.list)>0:
                j = self.list.pop(); self.njobs += 1
                return j,1
            else:
                return "stall",1
        return "stop",1
    def expire(self,id):
        print "Processing expired task ",id
        self.list.append("sleep "+str(10+int(30*random.random())))

#
# we create a dynamic launcher job to that will create new commands
# while running; an initial job list is provided here.
#
job = pylauncher.DynamicLauncher(
    joblist( [ "command1", "command2", "command3" ] )
    )
\end{verbatim}

\end{document}
